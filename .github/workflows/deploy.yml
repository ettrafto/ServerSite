name: Deploy (Cloudflare Access)

on:
  workflow_dispatch: {}
  push:
    branches: [ master ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      HOST: ssh.evantrafton.me
      USER: evantrafton
      APP_DIR: /opt/apps/dashboard
      SERVICE_NAME: dashboard

      # map your repo secrets to what cloudflared expects
      TUNNEL_SERVICE_TOKEN_ID: ${{ secrets.CF_ACCESS_CLIENT_ID }}
      TUNNEL_SERVICE_TOKEN_SECRET: ${{ secrets.CF_ACCESS_CLIENT_SECRET }}

    steps:
      - uses: actions/checkout@v4

      - name: Install cloudflared (client)
        run: |
          set -euo pipefail
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb
          cloudflared --version

      - name: Start ssh-agent and add key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: SSH connectivity smoke (non-interactive via service token)
        env:
          # ensure these are visible to ProxyCommand
          TUNNEL_SERVICE_TOKEN_ID: ${{ env.TUNNEL_SERVICE_TOKEN_ID }}
          TUNNEL_SERVICE_TOKEN_SECRET: ${{ env.TUNNEL_SERVICE_TOKEN_SECRET }}
        run: |
          set -euo pipefail
          ssh -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h \
                               --service-token-id $TUNNEL_SERVICE_TOKEN_ID \
                               --service-token-secret $TUNNEL_SERVICE_TOKEN_SECRET" \
              "$USER@$HOST" "whoami && hostname && test -w '$APP_DIR' && echo 'APP_DIR is writable ✅'"

      - name: Package repository (source only)
        run: |
          set -euo pipefail
          TAR="release-${GITHUB_SHA}.tgz"
          git archive --format=tar.gz -o "$TAR" HEAD
          echo "TAR=$TAR" >> "$GITHUB_ENV"

      - name: Upload package to server (/tmp) via scp
        env:
          TUNNEL_SERVICE_TOKEN_ID: ${{ env.TUNNEL_SERVICE_TOKEN_ID }}
          TUNNEL_SERVICE_TOKEN_SECRET: ${{ env.TUNNEL_SERVICE_TOKEN_SECRET }}
        run: |
          set -euo pipefail
          scp -o StrictHostKeyChecking=accept-new \
              -o ProxyCommand="cloudflared access ssh --hostname %h \
                               --service-token-id $TUNNEL_SERVICE_TOKEN_ID \
                               --service-token-secret $TUNNEL_SERVICE_TOKEN_SECRET" \
              "$TAR" "$USER@$HOST:/tmp/release.tgz"

      - name: Deploy, build, and restart on server
        env:
          TUNNEL_SERVICE_TOKEN_ID: ${{ env.TUNNEL_SERVICE_TOKEN_ID }}
          TUNNEL_SERVICE_TOKEN_SECRET: ${{ env.TUNNEL_SERVICE_TOKEN_SECRET }}
        run: |
          set -euo pipefail
          ssh -T -o StrictHostKeyChecking=accept-new \
                -o ProxyCommand="cloudflared access ssh --hostname %h \
                                 --service-token-id $TUNNEL_SERVICE_TOKEN_ID \
                                 --service-token-secret $TUNNEL_SERVICE_TOKEN_SECRET" \
                "$USER@$HOST" \
                "APP_DIR='$APP_DIR' SERVICE_NAME='$SERVICE_NAME' bash -s --" <<'REMOTE'
          set -euo pipefail

          echo "→ Deploying to: $APP_DIR"
          mkdir -p "$APP_DIR"
          tar -xzf /tmp/release.tgz -C "$APP_DIR"
          rm -f /tmp/release.tgz

          # Safe perms (optional)
          find "$APP_DIR" -type d -exec chmod 755 {} \;
          find "$APP_DIR" -type f -exec chmod 644 {} \;

          # Node build (if applicable)
          if [ -f "$APP_DIR/package.json" ]; then
            echo "→ Node project detected; installing & building"
            cd "$APP_DIR"
            if [ -f pnpm-lock.yaml ] && command -v pnpm >/dev/null 2>&1; then
              pnpm install --frozen-lockfile
              (pnpm -s build || true)
            elif [ -f yarn.lock ] && command -v yarn >/dev/null 2>&1; then
              yarn install --frozen-lockfile
              (yarn -s build || true)
            elif command -v npm >/dev/null 2>&1; then
              npm ci
              (npm run -s build || true)
            else
              echo "⚠️ No npm/yarn/pnpm found; skipping install/build"
            fi
          fi

          echo "→ Restarting service (Docker Compose → systemd → PM2 fallback)"
          RESTARTED=false

          # Detect a compose file robustly (compose.yaml, compose.yml, docker-compose.yaml, docker-compose.yml)
          cd "$APP_DIR"
          COMPOSE_FILE=""
          for f in compose.yaml compose.yml docker-compose.yaml docker-compose.yml; do
            if [ -f "$f" ]; then COMPOSE_FILE="$f"; break; fi
          done

          if [ -n "$COMPOSE_FILE" ] && command -v docker >/dev/null 2>&1; then
            echo "→ Using Compose file: $COMPOSE_FILE"
            if docker compose version >/dev/null 2>&1; then
              docker compose -f "$COMPOSE_FILE" pull || true
              docker compose -f "$COMPOSE_FILE" up -d --build
              RESTARTED=true
            elif command -v docker-compose >/dev/null 2>&1; then
              docker-compose -f "$COMPOSE_FILE" pull || true
              docker-compose -f "$COMPOSE_FILE" up -d --build
              RESTARTED=true
            fi
          elif [ -n "$COMPOSE_FILE" ]; then
            echo "⚠️ Docker not installed; skipping compose."
          else
            echo "ℹ️ No compose file found in $APP_DIR; skipping compose."
          fi

          # systemd
          if [ "$RESTARTED" = false ] && command -v systemctl >/dev/null 2>&1; then
            if systemctl list-unit-files | grep -q "^${SERVICE_NAME}\.service"; then
              echo "→ Restarting systemd service: $SERVICE_NAME"
              sudo -n systemctl daemon-reload || true
              sudo -n systemctl restart "$SERVICE_NAME"
              sudo -n systemctl --no-pager --full status "$SERVICE_NAME" || true
              RESTARTED=true
            fi
          fi

          # PM2
          if [ "$RESTARTED" = false ] && command -v pm2 >/dev/null 2>&1; then
            echo "→ Reloading via PM2: $SERVICE_NAME"
            pm2 reload "$SERVICE_NAME" || pm2 start npm --name "$SERVICE_NAME" -- start || true
            pm2 save || true
            RESTARTED=true
          fi

          if [ "$RESTARTED" = true ]; then
            echo "✅ Deployment complete and service restarted."
          else
            echo "⚠️ No restart method found (no compose/systemd/pm2). Deployment complete without restart."
          fi
          REMOTE
